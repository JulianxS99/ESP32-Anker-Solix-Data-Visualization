<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="README_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="anker-solix-2-balcony-power-plant-monitor" class="level1">
<h1>Anker&nbsp;Solix&nbsp;2 Balcony Power Plant Monitor</h1>
<p>This repository contains the firmware and documentation for an ESP32‑based display that visualises the daily energy production and consumption of an Anker&nbsp;Solix&nbsp;2 balcony power plant. The device uses a standalone ESP32‑2432S032C module with a built‑in <strong>3.2″ 320×240 pixel TFT LCD</strong> and capacitive touch. The module is based on a dual‑core ESP32 SoC with built‑in Wi‑Fi and Bluetooth. The display resolution is 240 × 320&nbsp;pixels and it supports 65 k&nbsp;colours.</p>
<section id="features" class="level2">
<h2 class="anchored" data-anchor-id="features">Features</h2>
<ul>
<li><strong>Standalone monitoring</strong> – The ESP32 connects directly to your Wi‑Fi network and retrieves data either from the <strong>Anker&nbsp;Solix cloud</strong> or a local <strong>smart‑meter</strong>. No additional servers or Raspberry&nbsp;Pi are required.</li>
<li><strong>Graphical display</strong> – A 24‑point curve shows the hourly <strong>generation</strong> (green) and <strong>consumption</strong> (red) of the current day. The graph is automatically scaled to the maximum value so that even small differences are visible.</li>
<li><strong>Numerical summaries</strong> – The current battery charge (in&nbsp;%), daily energy production and daily energy consumption (in&nbsp;kWh) are displayed below the graph.</li>
<li><strong>Dual modes</strong> – At compile time you can select between retrieving data from the <strong>Anker cloud</strong> (requires account credentials) or from a <strong>local smart‑meter</strong> running on your LAN.</li>
<li><strong>Manual refresh and timestamp</strong> – When touch support is enabled the firmware draws a <strong>Refresh</strong> button on the lower right of the screen. Tapping this button triggers an immediate update. Beneath the button the display shows the time of the last successful data retrieval in <code>HH:MM:SS</code> format.</li>
<li><strong>Well documented</strong> – The C++ source code is heavily commented to make it easier to customise.</li>
</ul>
</section>
<section id="hardware" class="level2">
<h2 class="anchored" data-anchor-id="hardware">Hardware</h2>
<p>This project targets the <strong>Sunton ESP32‑2432S032C</strong> development board (also marketed under various names on Amazon, AliExpress, etc.). The board combines an ESP32‑D0WDQ6 microcontroller with a <strong>3.2″ 320×240&nbsp;pixel 65 k‑colour touch display</strong> driven by an ST7789 controller【713159532338858†L31-L43】. The physical module size is approximately <strong>93.7&nbsp;×&nbsp;55&nbsp;mm</strong> and the effective display area is <strong>64.8&nbsp;×&nbsp;48.6&nbsp;mm</strong>【920421873094630†L216-L233】.</p>
</section>
<section id="file-structure" class="level2">
<h2 class="anchored" data-anchor-id="file-structure">File structure</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th>Path</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>src/main.cpp</code></td>
<td>Main Arduino sketch. Handles Wi‑Fi, API calls, graph drawing and user interface.</td>
</tr>
<tr class="even">
<td><code>src/secrets.h</code></td>
<td>Template for storing your Wi‑Fi credentials and API endpoints. <strong>Do not commit your real credentials</strong>.</td>
</tr>
<tr class="odd">
<td><code>README.md</code></td>
<td>This file. Explains how to build, flash and use the monitor.</td>
</tr>
</tbody>
</table>
</section>
<section id="dependencies" class="level2">
<h2 class="anchored" data-anchor-id="dependencies">Dependencies</h2>
<p>Install the following libraries via the Arduino IDE library manager or PlatformIO:</p>
<ul>
<li><strong>TFT_eSPI</strong> by Bodmer – used to drive the ST7789 TFT. After installing the library, edit <code>TFT_eSPI/User_Setup.h</code> and:
<ul>
<li>enable <code>#define ST7789_DRIVER</code>,</li>
<li>set <code>#define TFT_WIDTH  240</code> and <code>#define TFT_HEIGHT 320</code>,</li>
<li>configure the SPI pins according to your board. On the ESP32‑2432S032C the default wiring matches the examples in the TFT_eSPI library.</li>
</ul></li>
<li><strong>ArduinoJson</strong> by Benoît Blanchon – used to parse JSON responses.</li>
</ul>
<p>These libraries are available from the Arduino Library Manager. In PlatformIO you can add them to your <code>platformio.ini</code> dependencies.</p>
<p>The firmware uses the built‑in <code>HTTPClient</code> and <code>WiFi</code> libraries provided by the ESP32 core.</p>
<p>If you wish to use the on‑screen refresh button you must also install a <strong>GT911</strong> touch driver library such as <a href="https://github.com/alex-code/GT911"><code>alex-code/GT911</code></a> and set the <code>HAS_TOUCH</code> macro to <code>1</code> in <code>src/main.cpp</code>. Without touch support the button is drawn but cannot be pressed; the firmware will still refresh automatically every five minutes.</p>
</section>
<section id="configuration" class="level2">
<h2 class="anchored" data-anchor-id="configuration">Configuration</h2>
<ol type="1">
<li><p>Copy <code>src/secrets.h</code> to a new file named <code>src/secrets.h</code> (the template is included in this repository).</p></li>
<li><p>Open <code>src/secrets.h</code> in a text editor and set the following fields:</p>
<ul>
<li><p><strong>Wi‑Fi credentials</strong> – <code>WIFI_SSID</code> and <code>WIFI_PASSWORD</code> must match your home network.</p></li>
<li><p><strong>Anker cloud</strong> – if you plan to use the Anker cloud, provide your Anker account e‑mail in <code>ANKER_USER</code>, your password in <code>ANKER_PASSWORD</code>, the two‑letter country code in <code>ANKER_COUNTRY</code> and the API endpoints in <code>ANKER_AUTH_URL</code> and <code>ANKER_ENERGY_URL</code>. Consult the Anker API documentation or the <a href="https://github.com/thomluther/anker-solix-api">anker‑solix‑api</a> project for details on available endpoints. The energy endpoint must return JSON with the following structure:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode json code-with-copy"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"battery_percent"</span><span class="fu">:</span> <span class="fl">80.3</span><span class="fu">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"daily_generation"</span><span class="fu">:</span> <span class="fl">3.45</span><span class="fu">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"daily_consumption"</span><span class="fu">:</span> <span class="fl">2.10</span><span class="fu">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"generation_curve"</span><span class="fu">:</span> <span class="ot">[</span><span class="fl">0.0</span><span class="ot">,</span> <span class="fl">0.0</span><span class="ot">,</span> <span class="er">…</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">"consumption_curve"</span><span class="fu">:</span> <span class="ot">[</span><span class="fl">0.0</span><span class="ot">,</span> <span class="fl">0.0</span><span class="ot">,</span> <span class="er">…</span><span class="ot">]</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The curves must contain exactly 24 values corresponding to each hour of the day.</p></li>
<li><p><strong>Local smart‑meter</strong> – if you plan to fetch data from a local meter, provide its IP address or hostname in <code>SMARTMETER_HOST</code>, the API endpoint path in <code>SMARTMETER_ENERGY_ENDPOINT</code> (e.g.&nbsp;<code>/api/daily</code>) and optionally an authentication token in <code>SMARTMETER_TOKEN</code>.</p></li>
</ul></li>
<li><p>In <code>src/main.cpp</code> you can change the line <code>Mode currentMode = …;</code> to select either <code>Mode::MODE_ANKER_CLOUD</code> or <code>Mode::MODE_LOCAL_SMARTMETER</code> at compile time. Alternatively, you can add a button or touch handler to switch modes at runtime.</p></li>
<li><p>(Optional) To enable the on‑screen refresh button, set the macro <code>HAS_TOUCH</code> to <code>1</code> at the top of <code>src/main.cpp</code> and install the GT911 library. If <code>HAS_TOUCH</code> is left as <code>0</code> the button will be displayed but touches will be ignored.</p></li>
</ol>
</section>
<section id="building-and-flashing" class="level2">
<h2 class="anchored" data-anchor-id="building-and-flashing">Building and flashing</h2>
<section id="arduino-ide" class="level3">
<h3 class="anchored" data-anchor-id="arduino-ide">Arduino IDE</h3>
<ol type="1">
<li>Install the <strong>ESP32 board support package</strong> from the Arduino Boards Manager (use the latest 3.x version). Select <strong>Sunton ESP32 2432S032C</strong> or a generic ESP32‑WROVER module if the board is not listed.</li>
<li>Install the dependencies mentioned above (TFT_eSPI and ArduinoJson).</li>
<li>Configure TFT_eSPI according to your display as described in the <strong>Dependencies</strong> section.</li>
<li>Open <code>src/main.cpp</code> in the Arduino IDE. The IDE will automatically convert it to a sketch. Make sure <code>src/secrets.h</code> is present in the same directory.</li>
<li>Select the correct serial port and upload the sketch. On first boot the display will show a splash screen and then update every five minutes.</li>
</ol>
</section>
<section id="platformio" class="level3">
<h3 class="anchored" data-anchor-id="platformio">PlatformIO</h3>
<p>Alternatively you can use <a href="https://platformio.org/">PlatformIO</a>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode ini code-with-copy"><code class="sourceCode ini"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[env:sunton_esp32_display]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">platform </span><span class="ot">=</span><span class="st"> espressif32</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">board </span><span class="ot">=</span><span class="st"> esp32dev</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">framework </span><span class="ot">=</span><span class="st"> arduino</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">monitor_speed </span><span class="ot">=</span><span class="st"> </span><span class="dv">115200</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dt">lib_deps </span><span class="ot">=</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dt">  bodmer/TFT_eSPI</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">  bblanchon/ArduinoJson</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Adjust the board definition if PlatformIO has an entry for <code>esp32-2432s032c</code>. Place <code>src</code> and <code>include</code> directories into the PlatformIO project and build with <code>pio run</code> and upload with <code>pio run -t upload</code>.</p>
</section>
</section>
<section id="usage" class="level2">
<h2 class="anchored" data-anchor-id="usage">Usage</h2>
<p>After uploading the firmware the ESP32 will connect to the configured Wi‑Fi network and retrieve energy data every <strong>five minutes</strong>. If the data acquisition fails (e.g., due to network problems or incorrect endpoints) a message is displayed on the screen. Successful retrieval results in a coloured graph and numerical values. The green line represents the <strong>solar generation</strong>; the red line shows <strong>consumption</strong>. The values at the bottom show the <strong>battery charge</strong>, <strong>daily generation</strong> and <strong>daily consumption</strong>.</p>
<p>If you have enabled the GT911 touch driver, a <strong>Refresh</strong> button appears in the lower right corner. Tapping this button forces an immediate update regardless of the five‑minute schedule. The label below the button indicates the time (UTC) of the last successful update. If the system time has not been synchronised, the timestamp remains <code>--:--:--</code> until valid data is retrieved.</p>
<p>The device does not support deep sleep because the board’s integrated Li‑ion charger enters standby if the current consumption is too low【713159532338858†L35-L36】. Therefore the ESP32 remains active and updates the display periodically.</p>
</section>
<section id="limitations" class="level2">
<h2 class="anchored" data-anchor-id="limitations">Limitations</h2>
<ul>
<li>The Anker API is proprietary and may change. You need to provide the correct authentication and energy endpoints; otherwise the firmware will not fetch any data.</li>
<li>The sample implementation expects the energy endpoint to return 24 hourly values. If your meter provides a different sampling rate you must adjust <code>POINTS_PER_DAY</code> and the parsing logic accordingly.</li>
<li>If the battery charge or energy values are not present in the JSON response they are displayed as <code>--</code> on the screen.</li>
</ul>
</section>
<section id="license" class="level2">
<h2 class="anchored" data-anchor-id="license">License</h2>
<p>This project is released under the MIT License. See the <code>LICENSE</code> file for more information.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>